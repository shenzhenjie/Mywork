---idea terminal 
jps 查看当前的所有线程
jstack 【线程号】  查看线程栈帧

---linux 
jps	查看所有线程
pstree -p【线程号】  查看线程栈帧


为什么用多线程
利用资源

线程本质，为什难
多个工人对着一份说明书做各自的事情，哪个工人做的，做到哪里，出了异常都不知道。
异常处理只能向当前线程和当前方法栈抛出
共有变量公有，私有变量私有

thread是什么（只有调用star（）方法且没结束的thread对象实例代表线程）
线程实例

方法栈是什么
方法调用的过程，包含多个栈帧
多线程各自有自己的方法栈，方法调用的起点，也就是最底部只有两种可能Thread.run()和main()方法

栈帧是什么
每个线程有自己的栈帧，每调用一个方法就是一个栈帧，栈帧产生于方法，方法是说明书，每个线程根据说明书创建栈帧
线程调用方法，添加属于自己方法栈的栈帧
栈帧后进先出执行完出栈
是一块儿内存区域存放局部变量表和操作数栈执行字节码所需要的信息

线程和进程的区别
共享内容空间，线程组等于进程

在windows和linux的jvm中线程的底层模型
相同：代码中的线程一一映射到系统的线程上去执行，受操作系统的调度器控制
区别：linux中线程等于轻量级进程只是同个进程的线程共享一块儿内存
优点：实现简单
缺点：占用资源，上下文且换慢，灵活性差不受控制

线程生命周期
Thread内部类：state 
	new：star()方法创建
	runnable：线程正在执行代码或是等待资源（等待io传输）
	blocked：等待锁 synchronized 状态的 monitor lock
	waiting：特殊等待状态。jvm线程使用Object的wait()、notify()、notifyAll()这一套机制执行线程协同或是等待
	timed_waiting：waiting增加超时操作
	
Thread local（不同线程获取不同变量）
提供线程局部变量实例
interceptor






















